
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>python中涉及到类的多重继承及super()的调用</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab title="python中涉及到类的多重继承及super()的调用"
                  environment="web"
                  feedback-link="http://www.sctu.edu.cn">
    
      <google-codelab-step label="案例介绍" duration="0">
        <p>在python类中有关子类的多重继承所涉及的问题；如super函数，若是多个子类继承自相同的父类与不同的父类会有什么不同，当子类存在多个父类时，继承的先后顺序，让我们来一一探究一下，着其中的规律。<br>接下来有这样一串代码：</p>
<pre><code>class A(object):
    def __init__(self):
        print(&#39;A&#39;)
        super(A,self).__init__()
class B(object):
    def __init__(self):
        print(&#39;B&#39;)
        super(B,self).__init__()
class C(A):
    def __init__(self):
        print(&#39;C&#39;)
        super(C,self).__init__()
class D(A):
    def __init__(self):
        print(&#39;D&#39;)
        super(D,self).__init__()
class E(B,C):
    def __init__(self):
        print(&#39;E&#39;)
        super(E,self).__init__()
class F(C,D):
    def __init__(self):
        print(&#39;F&#39;)
        super(F,self).__init__()
class G(D,C,B):
    def __init__(self):
        print(&#39;G&#39;)
        super(G,self).__init__()
if __name__==&#39;__main__&#39;:
    f=F()
    g=G()
</code></pre>
<p>该代码涉及到多重继承问题，其中还涉及到了super这个函数。<br>运行这串代码我们会得到如下结果：<br><img src="img/c22a286803213827.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="super函数的用法" duration="0">
        <p>由上述代码我们可知，子类利用super函数来调用父类（超类），同理super()函数的语法:</p>
<pre><code>super(type[,object-or-type])
</code></pre>
<p>含义： type=类object-or-type=类，一般是self。<br>如上述C作为例子；用法：<br>首先super函数会找到C的父类(A)，然后把C的类对象转化为父类(A)的类对象，然后调用父类对象的方法。</p>


      </google-codelab-step>
    
      <google-codelab-step label="案例的解决" duration="0">
        <p>由上述的分析及结果我们可以得到一个结论：当多重继承中存在多个子类同时继承相同的父类时，且自身作为父类时（C,D均为F的父类），例如C,D两个子类同时去继承相同的父类（A）时，利用super()函数只会在最后一个调用父类（即D调用A）。<br>那若是不同的父类，那会出现什么情况呢？看如下代码：</p>
<pre><code>class A(object):
    def __init__(self):
        print(&#39;A&#39;)
        super(A,self).__init__()
class B(object):
    def __init__(self):
        print(&#39;B&#39;)
        super(B,self).__init__()
class C(A):
    def __init__(self):
        print(&#39;C&#39;)
        super(C,self).__init__()
class D(B):
    def __init__(self):
        print(&#39;D&#39;)
        super(D,self).__init__()
class E(B,C):
    def __init__(self):
        print(&#39;E&#39;)
        super(E,self).__init__()
class F(C,D):
    def __init__(self):
        print(&#39;F&#39;)
        super(F,self).__init__()
class G(D,C,B):
    def __init__(self):
        print(&#39;G&#39;)
        super(G,self).__init__()
if __name__==&#39;__main__&#39;:
    f=F()
    g=G()
</code></pre>
<p>当D的父类变为B时,输出结果变为:<br><img src="img/8f1e981d4725ce11.png"><br>由此可见，当父类变为不同时，super()就会分别调用各个父类，并输出每一个调用的父类，例子中的C,D就会分别调用他们的父类A和B，这样就会输出上述的结果。</p>


      </google-codelab-step>
    
      <google-codelab-step label="总结" duration="0">
        <p>涉及多重继承关系中super()函数并不是去让子类继承父类并输出，而是将自身，即子类的对象转化为父类的对象并调用父类，明白这一点问题就迎刃而解了。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
